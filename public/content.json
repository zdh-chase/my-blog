[{"title":"Gulp 配置（五）---图片篇","date":"2017-04-04T07:28:00.531Z","path":"2017/04/04/note5/","text":"图片整合成雪碧图，几kb的图片转化成base64写入css中，减少http请求。 gulp-base64需要引入的依赖1var base64 = require('gulp-base64'); 新建一个task:1234567891011gulp.task('base64', function() &#123; return gulp.src('./build/scss/*') .pipe(base64(&#123; baseDir: './build/scss/', extensions: ['svg', 'png', /\\.jpg#datauri$/i], exclude: [/\\.server\\.(com|net)\\/dynamic\\//, '--live.jpg'], maxImageSize: 8*1024, // bytes debug: true &#125;)) .pipe(gulp.dest('./build/scss'));&#125;); gulp-css-spriter需要引入的依赖1var spriter = require('gulp-css-spriter'); 123456789101112131415161718gulp.task('mergeScss', ['cleanScss'],function ()&#123; var timestamp = +new Date(); return gulp.src(['./static/scss/*.scss']) .pipe(sass().on('error', sass.logError)) .pipe(spriter(&#123; // 生成的spriter的位置 'spriteSheet': './build/img/sprite-'+timestamp+'.png', // 生成样式文件图片引用地址的路径 // 如下将生产：backgound:url(../images/sprite20324232.png) 'pathToSpriteSheetFromCSS': '../img/sprite-'+timestamp+'.png' &#125;)) .pipe(minifycss()) .pipe(rev()) //- 文件名加MD5后缀 .pipe(gulp.dest('./build/scss/')) .pipe(rev.manifest()) //- 生成一个rev-manifest.json .pipe(gulp.dest('./rev')) //- 将 rev-manifest.json 保存到 rev 目录内 .pipe(notify(&#123; message: 'mergeScss task ok' &#125;));&#125;); css:12.x&#123;width: 50px;height: 50px;background: url(../img/x.png?__spriter) 0 0 no-repeat;&#125;.y&#123;width: 50px;height: 50px;background: url(../img/y.png) 0 0 no-repeat;&#125; 配置gulp-css-spriter默认会对样式文件里，所有的background/background-image的图片合并， 但实际项目中，我们不是所有的图片都需要合并。 123background-image:url(../img/x.png?__spriter);//有?__spriter后缀的合并background-image:url(../img/y.png);//不合并 修改gulp-css-spriter源文件 第43行：1234567891011if(transformedDeclaration.property === 'background-image') &#123; return cb(transformedDeclaration, declarationIndex, declarations); &#125; // Background is a shorthand property so make sure `url()` is in there else if(transformedDeclaration.property === 'background') &#123; var hasImageValue = spriterUtil.backgroundURLRegex.test(transformedDeclaration.value); if(hasImageValue) &#123; return cb(transformedDeclaration, declarationIndex, declarations); &#125; &#125; 更新为：123456789101112131415if(transformedDeclaration.property === 'background-image' &amp;&amp; /\\?__spriter/i.test(transformedDeclaration.value)) &#123; transformedDeclaration.value = transformedDeclaration.value.replace('?__spriter',''); return cb(transformedDeclaration, declarationIndex, declarations); &#125; // Background is a shorthand property so make sure `url()` is in there 且判断url是否有?__spriter后缀 else if(transformedDeclaration.property === 'background' &amp;&amp; /\\?__spriter/i.test(transformedDeclaration.value)) &#123; transformedDeclaration.value = transformedDeclaration.value.replace('?__spriter',''); var hasImageValue = spriterUtil.backgroundURLRegex.test(transformedDeclaration.value); if(hasImageValue) &#123; return cb(transformedDeclaration, declarationIndex, declarations); &#125; &#125; over","tags":[{"name":"base64","slug":"base64","permalink":"http://zengdh.com/tags/base64/"},{"name":"spriter","slug":"spriter","permalink":"http://zengdh.com/tags/spriter/"}]},{"title":"Gulp 配置（四）---模板篇","date":"2017-04-03T07:19:46.802Z","path":"2017/04/03/note4/","text":"提取公共html页面为实际开发提供了便捷，这里引入gulp-file-include做公共模块复用。 gulp-file-include需要引入的依赖1var fileinclude = require('gulp-file-include'); 新建一个task:123456789gulp.task('fileinclude', function() &#123; // 适配src中所有文件夹下的所有html，排除src下的include文件夹中html gulp.src(['./src/view/*.html','!./src/view/common/*.html']) .pipe(fileinclude(&#123; prefix: '@@', basepath: '@file' &#125;)) .pipe(gulp.dest('./build/view/'));&#125;); gulp task已经写好了，这里新建两个公共html页面，header.html和footer.html 12345header.html&lt;div&gt;这是头部&lt;/div&gt;footer.html&lt;div&gt;这是页脚&lt;/div&gt; 引入公共组件123@@include('common/header.html') &lt;div&gt;主内容&lt;/div&gt;@@include('common/footer.html') 编译后生产环境下的html123&lt;div&gt;这是头部&lt;/div&gt;&lt;div&gt;主内容&lt;/div&gt;&lt;div&gt;这是页脚&lt;/div&gt; 至此完成了html模板复用，结合上一章的自动刷新，更新下watch，将fileinclude放入watch中监听html，并刷新12345gulp.task('watch', function() &#123; gulp.watch(paths.html,['fileinclude','html']); gulp.watch(paths.scripts,['mergeScripts','html']); gulp.watch(paths.scss,['mergeScss','html']);&#125;) over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"gulp-file-include","slug":"gulp-file-include","permalink":"http://zengdh.com/tags/gulp-file-include/"}]},{"title":"Gulp 配置（三）---service篇","date":"2017-04-03T06:40:26.081Z","path":"2017/04/03/note3/","text":"实际开发中，如果每次修改html、sass、js都要手动去执行编译命令，这将是一件很痛苦的事，所以配置一个本地服务，让它实时编译刷新是很必要的。 gulp-connect需要引入的依赖1var connect = require('gulp-connect'); 新建一个task:12345678gulp.task('connect', function() &#123; connect.server(&#123; // host: '192.168.x.x', //地址，可不写，不写的话，默认localhost port: 3000, //端口号，可不写，默认8000 root: './', //当前项目主目录 livereload: true //自动刷新 &#125;);&#125;); 这样就能在本地启一个服务了，但是这样还不够，我们需要去监听项目的文件是否发生更改，如果有更改就自动去编译，这里需要用到gulp-watch gulp-watch引入依赖1var sass = require('gulp-watch'); 新建一个task 12345678var paths = &#123; scripts: ['./src/js/*.js'], scss: './src/scss/*.scss',&#125;;gulp.task('watch', function() &#123; gulp.watch(paths.scripts,['mergeScripts']); gulp.watch(paths.scss,['mergeScss']);&#125;) 用watch去监听文件，当js和css发生变化时自动编译生成，但是每次都需要按F5才能更新页面，这里再写一个task去自动刷新页面，毕竟我这么懒，F5也懒得去按。 再新建一个task123456gulp.task('html', function() &#123; return gulp.src('./build/view/*.html')//这里的路径时生产文件的路径 .pipe(connect.reload());&#125;);注：task里要加return，不加return，task和里面的gulp流是异步执行的。 将它放入watch中123gulp.watch(paths.html,['html']);gulp.watch(paths.scripts,['mergeScripts','html']);gulp.watch(paths.scss,['mergeScss','html']); 这样就可以在修改源文件的同时，让gulp去自动生成需要的生产文件，这里再合并一下task，丢在一个task里面，方便使用 1gulp.task('service', ['connect', 'watch']); http-proxy-middleware 代理跨域1234567891011121314151617181920gulp.task('proxy', function() &#123; connect.server(&#123; root: ['./'], port: 3000, livereload: true, middleware: function(connect, opt) &#123; return [ proxy('/api', &#123; target: 'http://localhost:8080', changeOrigin:true &#125;), proxy('/otherServer', &#123; target: 'http://IP:Port', changeOrigin:true &#125;) ] &#125; &#125;);&#125;); over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"gulp-watch","slug":"gulp-watch","permalink":"http://zengdh.com/tags/gulp-watch/"},{"name":"gulp-connect","slug":"gulp-connect","permalink":"http://zengdh.com/tags/gulp-connect/"}]},{"title":"Gulp 配置（二）---sass篇","date":"2017-04-03T05:53:17.480Z","path":"2017/04/03/note2/","text":"sass、less、stylus都是css预处理框架，它可以提高开发效率，编写富有表现力的、动态的、健壮的CSS。 这里选择sass gulp css task需要引入的依赖12var minifycss = require('gulp-minify-css'), //压缩css rev = require('gulp-rev'); //- 对文件名加MD5后缀 123456789gulp.task('mergeCss',['cleanCss'], function() &#123; //- 创建一个名为 mergeCss 的 task return gulp.src(['./src/css/*.css']) //- 需要处理的css文件，放到一个字符串数组里 //.pipe(concat(*)) //- 合并后的文件名 .pipe(minifycss()) //- 压缩处理成一行 .pipe(rev()) //- 文件名加MD5后缀 .pipe(gulp.dest('./build/css/')) //- 输出文件本地*/ .pipe(rev.manifest()) //- 生成一个rev-manifest.json .pipe(gulp.dest('./rev')); //- 将 rev-manifest.json 保存到 rev 目录内&#125;); 普通css文件的gulp task任务，主要是css压缩+MD5时间戳+HTML路径更换 sass在开发过程中，sass需要编译才能使用，可以用命令行编译，gui编译（推荐koala），编辑器编译，在线编译等等，这里我结合gulp引入gulp-sass来编译。sass文件后缀分两种，scss和sass，一个使用{}，一个不使用，我选择scss，可读性高一些。 引入依赖1var sass = require('gulp-sass'); task任务12345678gulp.task('mergeScss', ['cleanScss'],function ()&#123; return gulp.src(['./src/scss/*.scss']) .pipe(sass().on('error', sass.logError)) .pipe(rev()) //- 文件名加MD5后缀 .pipe(gulp.dest('./build/scss/')) .pipe(rev.manifest()) //- 生成一个rev-manifest.json .pipe(gulp.dest('./rev')); //- 将 rev-manifest.json 保存到 rev 目录内&#125;); 这里编译后的css文件名是通过原文件名和md5以连字符形式命名的（例：a-f7e3d6869b.css），每次修改css后生成的文件名都不一样，需要清除原有的旧文件，否则会堆积很多没用的css，我更喜欢在html中引入css时在路径后面加‘?v={time}’的形式，这里我选择去修改node_modules里面的js文件来满足我的需求。 打开 node_modules\\gulp-rev\\index.js第144行：1manifest[originalFile] = revisionedFile; 更新为：1manifest[originalFile] = originalFile + '?v=' + file.revHash; //file.revHash是md5字符串，可以换成new Date().getTime()来获取当前时间的毫秒戳 打开 nodemodules\\gulp-rev\\nodemodules\\rev-path\\index.js第10行：1return filename + '-' + hash + ext; 更新为：1return filename + ext; 打开 node_modules\\gulp-rev-collector\\index.js第31行：1if ( !_.isString(json[key]) || path.basename(json[key]).replace(new RegExp( opts.revSuffix ), '' ) !== path.basename(key) ) &#123; 更新为：1if ( path.basename(json[key]).split('?')[0] !== path.basename(key) ) &#123; 路径替换引入依赖1var revCollector = require('gulp-rev-collector'); gulp task 123456789101112gulp.task('scssrev',['mergeScss'],function() &#123; return gulp.src( ['./rev/*.json','./build/view/*.html']) //- 读取 rev-manifest.json 文件以及需要进行css名替换的文件 .pipe(revCollector( &#123; replaceReved: true /*dirReplacements: &#123;//指定路径替换 '/static/scss': '/build/scss' &#125;*/ &#125; )) //- 执行文件内css名的替换 .pipe(gulp.dest(\"./build/view/\")); //- 替换后的文件输出的目录 &#125;); 最后这些编译后的css文件会以*.css?v={time}的形式引入，解决浏览器缓存机制。over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"css","slug":"css","permalink":"http://zengdh.com/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://zengdh.com/tags/sass/"}]},{"title":"Gulp 配置（一）---seaJs篇","date":"2017-04-03T01:54:59.771Z","path":"2017/04/03/note/","text":"Gulp.js 是基于 Node.js 构建的，可以建项目并减少频繁的 IO 操作的化构建工具这里我采用 seajs来管理我的javascript代码，提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。 gulp安装就不赘述 引入seajs1&lt;script type=\"text/javascript\" src=\"../../src/js/sea.js\"&gt;&lt;/script&gt; 配置seajs1234567891011121314seajs.config(&#123; paths: &#123; 'src': '../../src/' //路径配置 &#125;, alias: &#123;//别名配置 jquery:'jquery.js', index:'src/js/index.js' &#125;, map: [//映射配置 [ /^(.*\\.(?:css|js))(.*)$/i, '$1?201703281819' ] ], preload: ['jquery'] // 预加载项 &#125;);seajs.use([\"jquery\",\"index\"]); //模块加载 更多配置项&gt;&gt; 新建两个js文件a.js和b.js12345678910111213141516171819202122232425a.js:define(function(require, exports, module) &#123; var AJS=&#123; init:function()&#123; &#125;, aDom:function()&#123; console.log('来自a.js的内容'); &#125; &#125;; module.exports=AJS;&#125;)b.js:define(function(require, exports, module) &#123; var BJS=&#123; init:function()&#123; &#125;, aDom:function()&#123; console.log('来自b.js的内容'); &#125; &#125;; module.exports=BJS;&#125;) index.js引入a.js和b.js的方法123456789101112define(function(require, exports, module) &#123; var AJS=require('a'); var BJS=require('b'); var INDEX=&#123; init:function()&#123; console.log('来自index.js的内容'); AJS.aDom(); BJS.bDom(); &#125; &#125;; module.exports=INDEX.init();&#125;) 打开引入index.js的html文件1seajs.use([\"index\"]); //引入index.js 这里可以看到index.js中成功引入了a.js和b.js的方法，再看一下Network这边加载了三个js文件，这并不符合我的需求，我希望我引入某个js文件的方法时，只需要加载那个方法，而不是整个js文件都加载进来，所以我需要合并js，添加一个gulp task任务123456789gulp.task('mergeScripts',function () &#123; return gulp.src(['./src/js/a.js','./src/js/b.js','./src/js/index.js']) .pipe(uglify(&#123;//压缩js mangle: true,//类型：Boolean 默认：true 是否修改变量名 mangle: &#123; except: ['require', 'exports', 'module', '$'] &#125;//排除混淆关键字 &#125;)) .pipe(concat('index.js')) //生成js .pipe(gulp.dest('./build/js/')); //生成合并后的js的路径 &#125;); 1gulp mergeScripts 合并是合并了，但是还是加载了三个js这里需要引入gulp-seajs-transport来具象化js模块12var transport = require('gulp-seajs-transport');.pipe(transport()); 完成，既加载了我所需要的方法，又减少了http请求over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"seajs","slug":"seajs","permalink":"http://zengdh.com/tags/seajs/"},{"name":"gulp-seajs-transport","slug":"gulp-seajs-transport","permalink":"http://zengdh.com/tags/gulp-seajs-transport/"}]}]