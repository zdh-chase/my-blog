[{"title":"Node.js 路由配置及模板引入","date":"2017-11-14T03:32:24.446Z","path":"2017/11/14/note13/","text":"node.js的一些基本路由配置，以及前端模板引擎引入，多接口请求并发及服务端渲染数据，跨域请求转发等.. express框架及nunjucks模板引入12345678910111213var express = require('express');var nunjucks = require('nunjucks');var app = express();nunjucks.configure('views', &#123; autoescape: true, express: app, watch:true, noCache: true&#125;);// view engine setupapp.set('views', path.join(__dirname, 'views'));app.set('view engine', 'html'); 路由配置routers.js第一种写法：1234567var express = require('express');var router = express.Router();router.get('/', function(req, res, next) &#123; res.render('页面地址', &#123; title: ''&#125;);&#125;);module.exports = router; 第二种写法：12345module.exports = function(app) &#123; app.get('自定义路由地址', function (req, res) &#123; res.render('页面地址', &#123; title: ''&#125;); &#125;);&#125;; 服务端接口请求单条接口请求12345678910var express = require('express');var router = express.Router();var request = require('request');router.get('/', function(req,res,next) &#123; request(&#123;url: '',gzip:true,headers:&#123;'User-Agent': 'chrome'&#125;&#125;,function(error, response, body) &#123; var data = JSON.parse(body);//数据处理 res.render('页面地址', &#123; data: data&#125;); &#125;&#125;)&#125;) 多条接口并发请求123456789101112131415var request = require('request-promise');var obj = function(app) &#123; app.get('路由地址', function (req, res) &#123; var api1 = request(&#123;url:'接口地址',gzip:true,headers:&#123;'User-Agent': 'chrome'&#125;&#125;); var api2 = request(&#123;url:'接口地址',gzip:true,headers:&#123;'User-Agent': 'chrome'&#125;&#125;); Promise.all([api1,api2]).then(function(results) &#123; var data1 = JSON.parse(results[0]).result.obj; var data2 = JSON.parse(results[1]).result.obj; res.render('页面地址', &#123; title: '', data1: data1, data2: data2&#125;); &#125;).catch(function()&#123; &#125;); &#125;);&#125;module.exports = obj; app.js 引入路由配置第一种：123var obj = require('router文件夹下的单个路由配置文件');var app = express();app.use('自定义路由地址', obj); 第二种：123var obj = require('router文件夹下的单个路由配置文件');var app = express();obj(app); 错误路由指向当页面发生404、500等错误时，路由配置指向123456789app.use(function(err, req, res, next) &#123; //set locals, only providing error in development //res.locals.message = err.message; //res.locals.error = req.app.get('env') === 'development' ? err:err; // render the error page res.status(err.status);//http错误状态码 res.render('error页面地址',&#123;error:err&#125;);//根据错误状态码渲染不同模板数据&#125;);","tags":[{"name":"express","slug":"express","permalink":"http://zengdh.com/tags/express/"},{"name":"node.js","slug":"node-js","permalink":"http://zengdh.com/tags/node-js/"},{"name":"nunjucks","slug":"nunjucks","permalink":"http://zengdh.com/tags/nunjucks/"},{"name":"request-promise","slug":"request-promise","permalink":"http://zengdh.com/tags/request-promise/"}]},{"title":"css预编译工具-sass","date":"2017-10-23T03:20:19.094Z","path":"2017/10/23/note12/","text":"记录sass使用的日常…. 常用mixin1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@mixin font-dpr($font-size) &#123; font-size: $font-size; [data-dpr=\"2\"] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr=\"3\"] &amp; &#123; font-size: $font-size * 3; &#125;&#125;$baseFontSize: 100;$FontSize: 16;@mixin px2rem($name, $px1)&#123; #&#123;$name&#125;: ($px1 / $baseFontSize) * 1rem;&#125;@mixin bg-image($url,$type) &#123; background-image: url($url + \"@2x.\"+$type); @media (-webkit-min-device-pixel-ratio: 3), (min-device-pixel-ratio: 3) &#123; background-image: url($url + \"@3x.\"+$type); &#125;&#125;@mixin clearfix() &#123; &amp;:before, &amp;:after &#123; content: \"\"; display: table; &#125; &amp;:after &#123; clear: both; &#125;&#125;@mixin remCalc($props,$sizes,$base:$baseFontSize)&#123; $values: (); $sublists: false; @each $s in $sizes &#123; @if type-of($s) == list &#123; $sublists: true; $vv: (); @each $ss in $s &#123; $vv: append($vv,if(type-of($ss) == number, #&#123;$ss / $base&#125;rem, $ss)); &#125; $values: append($values,join((), $vv)); &#125; @else &#123; $values: append($values,if(type-of($s) == number, #&#123;$s / $base&#125;rem, $s)); &#125; &#125; $value: join((), $values, if($sublists,comma,space)); @each $prop in $props &#123;#&#123;$prop&#125;: $value&#125;&#125;@mixin css3($property, $value) &#123; @each $prefix in -webkit-, -moz-, -ms-, -o-, '' &#123; #&#123;$prefix&#125;#&#123;$property&#125;: ($value / $baseFontSize) * 1rem; &#125;&#125;@mixin css3fn($property, $value) &#123; @each $prefix in -webkit-, -moz-, -ms-, -o-, '' &#123; #&#123;$prefix&#125;#&#123;$property&#125;: $value; &#125;&#125;","tags":[{"name":"sass","slug":"sass","permalink":"http://zengdh.com/tags/sass/"}]},{"title":"移动端开发笔记本","date":"2017-10-23T01:57:58.753Z","path":"2017/10/23/note11/","text":"移动wap开发笔记… 1.移动端rem布局通过js动态计算html的font-size值，通过rem作为单位进行开发，推荐使用sass、scss等预编译css开发工具，方便数值转换，或者用sublime插件转换js代码:123456function resize()&#123; var e=(navigator.userAgent,+document.documentElement.clientWidth/750)*100; window.remFontSize=e=100&gt;e?e:100, document.documentElement.style.fontSize=e+\"px\"&#125;var b=null,ua=navigator.userAgent;window.addEventListener(\"resize\",function()&#123;clearTimeout(b),b=setTimeout(resize,50)&#125;,!1),resize() 或者采用手淘flexible计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118;(function(win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector('meta[name=\"viewport\"]'); var flexibleEl = doc.querySelector('meta[name=\"flexible\"]'); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); if (metaEl) &#123; //console.warn('将根据已有的meta标签来设置缩放比例'); var match = metaEl.getAttribute('content').match(/initial\\-scale=([\\d\\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; var content = flexibleEl.getAttribute('content'); if (content) &#123; var initialDpr = content.match(/initial\\-dpr=([\\d\\.]+)/); var maximumDpr = content.match(/maximum\\-dpr=([\\d\\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; &#125; docEl.setAttribute('data-dpr', dpr); if (!metaEl) &#123; metaEl = doc.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement('div'); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; &#125; function refreshRem()&#123; var width = docEl.getBoundingClientRect().width; // if (width / dpr &gt; 540) &#123; // width = 540 * dpr; // &#125; //var rem = width / 10; var rem = 100 * (width / 750); docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem; &#125; win.addEventListener('resize', function() &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener('pageshow', function(e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); if (doc.readyState === 'complete') &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125; else &#123; doc.addEventListener('DOMContentLoaded', function(e) &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125;, false); &#125; refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function(d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === 'string' &amp;&amp; d.match(/rem$/)) &#123; val += 'px'; &#125; return val; &#125; flexible.px2rem = function(d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === 'string' &amp;&amp; d.match(/px$/)) &#123; val += 'rem'; &#125; return val; &#125;&#125;)(window, window['lib'] || (window['lib'] = &#123;&#125;)); 2.移动端IOS click事件点击无效解决方案： 1.将 click 事件直接绑定到目标元素（即 .target）上 2.将目标元素换成 a或者 button 等可点击的元素 3.将 click 事件委托到非 document 或 body 的父级元素上 4.给目标元素加一条样式规则 cursor: pointer;推荐使用第4种方案。 3.移动端wap视频开发需求：检测当前网络状态，如果处于非wifi状态下，提示用户该网络处于非wifi状态，播放视频需要消耗手机流量html5组件：video第三方组件：tvp.player.js zepto.js开发思路：1.网络状态检测code:123456789101112131415161718192021222324252627var wifi = true;var ua = window.navigator.userAgent;var con = window.navigator.connection;// 如果是微信if(/MicroMessenger/.test(ua))&#123;// 如果是微信6.0以上版本，用UA来判断if(/NetType/.test(ua))&#123;if(ua.match(/NetType\\/(\\S*)/)[1] != 'WIFI')&#123;wifi = false;&#125;// 如果是微信6.0以下版本，调用微信私有接口WeixinJSBridge&#125;else&#123;document.addEventListener(\"WeixinJSBridgeReady\",function onBridgeReady()&#123;WeixinJSBridge.invoke('getNetworkType',&#123;&#125;,function(e)&#123;if(e.err_msg != \"network_type:wifi\")&#123;wifi = false;&#125;&#125;);&#125;);&#125;// 如果支持navigator.connection&#125;else if(con)&#123;var network = con.type;if(network != \"wifi\" &amp;&amp; network != \"2\" &amp;&amp; network != \"unknown\")&#123; //unknown是为了兼容Chrome Canarywifi = false;&#125;&#125;; 2.初始化video组件123456789101112131415var video = new tvp.VideoInfo();var videoId = '';//视频vidvar videoPic = '';//默认图片地址video.setVid(videoId);//视频vidvar player = new tvp.Player();//视频高宽player.setCurVideo(video);player.addParam(\"autoplay\",\"0\");//是否自动播放，1为自动播放，0为不自动播放player.addParam(\"showend\",0);player.addParam(\"adplay\",0);player.addParam(\"wmode\",\"transparent\");player.addParam(\"controls\",\"0\");player.addParam(\"preload\",\"none\");player.addParam(\"pic\",videoPic);//默认图片地址// player.addParam(\"flashskin\", \"\");//是否调用精简皮肤，不使用则删掉此行代码player.write(\"videoCon\"); 3.判断网络状态选择不同的显示方式4.点击播放时，Android会自动全屏并显示加载动画百分比，ios会延迟反应，等加载一段才弹出视频窗口，这里对ios做一个加载检测处理，在弹出视频窗口之前做一个动画过渡12345678910111213video.onplay = function() &#123;var checkPlay=setInterval(function()&#123;//检测currentTime是否开始播放if(video.currentTime&gt;0) &#123;//去掉加载动画，结束定时器检测clearInterval(checkPlay);&#125;;&#125;,50)&#125;//点击继续播放事件$('body').on('click','播放按钮',function()&#123;//去掉遮罩，显示加载动画video.play();&#125;) 4.移动端wap唤起QQ链接需求:点击QQ链接弹出QQ聊天窗口，如果当前手机没安装QQ则跳转至下载app链接code:12345678910111213141516171819202122var userAgentInfo = navigator.userAgent;var isAndroid = userAgentInfo.indexOf('Android') &gt; -1 || userAgentInfo.indexOf('Adr') &gt; -1;//android终端var isiOS = !!userAgentInfo.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端var qqId = '客服QQ号码';var loadDateTime = new Date();var checkTime = setTimeout(function () &#123;var timeOutDateTime = new Date();if (!loadDateTime || timeOutDateTime - loadDateTime &lt;5010) &#123;//5秒响应时长if(isAndroid) &#123;location.href=\"https://qd.myapp.com/myapp/qqteam/AndroidQQ/mobileqq_android.apk\";&#125;else if(isiOS) &#123;location.href=\"https://itunes.apple.com/cn/app/qq/id444934666?mt=8\";&#125;else &#123;location.href=\"https://qd.myapp.com/myapp/qqteam/AndroidQQ/mobileqq_android.apk\";//market://details?id=com.tencent.mobileqq 打开跳转应用市场//http://app.mi.com/details?id=com.tencent.mobileqq 小米应用市场&#125;;&#125;clearTimeout(checkTime);&#125;,5000);//部分安卓手机弹出QQ有确认操作，不会直接弹出QQlocation.href = \"mqqwpa://im/chat?chat_type=wpa&amp;uin=\"+qqId+\"&amp;version=1&amp;src_type=web&amp;web_src=bjhuli.com\";","tags":[{"name":"移动端wap开发","slug":"移动端wap开发","permalink":"http://zengdh.com/tags/移动端wap开发/"}]},{"title":"日常踩坑笔记本","date":"2017-06-16T02:45:15.024Z","path":"2017/06/16/note10/","text":"记录日常开发各种坑坑洼洼，吾日三省吾身…. 1.IE8、IE9 ajax跨域不发起请求W3C CORS（跨域资源共享）是对于跨域请求的一个规范，目前各个主流浏览器都实现了这个规范，IE8开始，增加了XDomainRequest作为跨域请求的对象，而Firefox与Chrom则CORS直接实现在XMLHttpRequest对象中，更方便使用。不过IE10中，XMLHttpRequest对象也实现了CORS。 XDomainRequest:1.仅只是 GET 和 POST 两个方法。2.支持的事件有：onerror，onload，onprogress，ontimeout3.提供的方法：abort，open，send4.提供的属性：contentType， responseText，timeout demo:1234567891011121314151617181920212223var url = 'xxxxxxxxx';var xdr = new XDomainRequest();xdr.onload = function() &#123; console.log(xdr.responseText);&#125;;xdr.onerror = function() &#123; console.log(\"error\");&#125;; xdr.timeout = 3000;xdr.ontimeout = function() &#123; console.log(\"timeout\");&#125;; xdr.open(\"get\", url);xdr.send();//兼容处理if (window.XDomainRequest) &#123; &#125;else if (window.XMLHttpRequest) &#123; &#125; 2.IE10以下高德api接口返回数据未知错误高德地图api接口1http://restapi.amap.com/v3/geocode/geo?key=&lt;您的key&gt;&amp;address=杭州 但在ie10以下返回的结果时未知错误。。查阅高德地图文档错误后，给出的反馈是传参时中文字符进行url编码转换1'https://restapi.amap.com/v3/geocode/geo?key=&lt;您的key&gt;&amp;address=' + encodeURI(地址)","tags":[{"name":"坑坑洼洼踩踩踩","slug":"坑坑洼洼踩踩踩","permalink":"http://zengdh.com/tags/坑坑洼洼踩踩踩/"}]},{"title":"初探mongodb（二）","date":"2017-06-02T07:53:27.165Z","path":"2017/06/02/note9/","text":"mongodb安装完成后，开始实战操作，这里使用express框架和mongodb可视化工具Robomongo一起搭配使用。 1.安装expressnpm安装太慢，推荐cnpm,使用淘宝镜像1npm install -g cnpm --registry=https://registry.npm.taobao.org 全局安装：cnpm install -g express项目范围内安装： cnpm install express –save 安装完express，在项目根目录新建app.js12345678910111213var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World!');&#125;);var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 打开cmd，cd至项目目录，启动node app.js即可运行服务 2.可视化工具Robomongo官网传送门下载安装完成后，打开Robomongo点击Create,输入Name，以及Address，端口默认为27017，地址Address和端口号一般不用更改。这样名为test的mongodb连接创建完毕。 3.MongoDB和MySQL 4.创建数据库这里取名testDB,右键testDB下的collection新建表这样一张表就建好了，然后往表里添加字段和数据，右键表名点击insert documetMongoDB数据库中文档(每一行的数据)的数据结构和JSON基本一样，所有存储在集合中的数据都是BSON格式，BSON是一种类JSON的一种二进制形式的存储格式，简称Binary JSON。因此，我们在插入数据时，只要像JSON格式那样输入我们想要插入的数据。点击save保存即可成功插入数据123456&#123; userName:'zdh', age:18, sex:'男', job:'前端'&#125; 点击save即可保存至表中： 5.连接数据库使用MongoDB原生自带的API来创建连接，直接在app.js输入以下代码1234567891011121314151617181920212223var MongoClient = require('mongodb').MongoClient, DB_CONN_STR = 'mongodb://localhost:27017/testDB'; //数据库为 testDBvar selectData = function(db, callback) &#123; //连接到user表 var collection = db.collection('user'); //查询数据 var whereStr = &#123;\"userName\":'zdh'&#125;; collection.find(whereStr).toArray(function(err, result) &#123; if(err) &#123; console.log('Error:'+ err); return; &#125; callback(result); &#125;);&#125; MongoClient.connect(DB_CONN_STR, function(err, db) &#123; console.log(\"连接成功！\"); selectData(db, function(result) &#123; console.log(result); db.close(); &#125;);&#125;); 6.使用Mongoose连接数据库除了使用MongoDB原生自带的API来创建连接外，也可以使用Mongoose配合操作，mongoose文档（传送门） app.js中使用mongoose:123456789101112131415161718192021222324252627282930const pkg = require('./package')const express = require('express')const bodyParser = require('body-parser')const mongoose = require('mongoose')const user = require('./api/user')mongoose.connect('mongodb://localhost/testDB')mongoose.Promise = global.Promise const db = mongoose.connection;db.on('error', function () &#123; console.log('Database connection error.');&#125;);db.once('open', function () &#123; console.log('The Database has connected.')&#125;);const app = express()const port = process.env.PORT || 3000app.use(bodyParser.json())app.use(bodyParser.urlencoded(&#123; extended: true &#125;))app.use(express.static('dist'))app.use('/api',user)app.listen(port, () =&gt; &#123; console.log(`$&#123;pkg.name&#125; listening on port $&#123;port&#125;`)&#125;)module.exports = app 在项目根目录下新建了api文件夹，用于存放操作数据库的接口方法，api文件下user.js如下：1234567891011121314151617181920212223242526272829303132333435const express = require('express')const router = express.Router()const User = require('../models/user')//查询user表中的数据router.get('/userList', (req, res) =&gt; &#123; User.find(function(err,persons)&#123; if (err) &#123; res.json(err) &#125;else &#123; res.json(persons) &#125; &#125;)&#125;)//往user表中插入数据router.get('/insertUser', (req,res) =&gt; &#123; var user = new Movie(&#123; userName : 'zengdh', age : '20', sex : '男', job : '前端攻城狮' &#125;); user.save(function (err, results) &#123; if (err) &#123; res.send(\"Error:\" + err) &#125; else &#123; res.send(&#123; message: '数据添加成功', data: results &#125;) &#125; &#125;);&#125;) 在项目根目录下新建models文件夹，用于存放数据模型，这里models下user.js内容如下：1234567891011const mongoose = require('mongoose')const userSchema =new mongoose.Schema(&#123; userName: &#123; type: String &#125;,//用户名 age: &#123; type: Number &#125;, // 年龄 sex: &#123; type: String &#125;,// 性别 job: &#123; type: String &#125;, // 工作&#125;,&#123;collection:'user'&#125;)// 这边collection如果不写的话，在调用api接口的时候，会在数据库中新建一张后缀名加了s的表，即usersconst Movie = module.exports = mongoose.model('user',userSchema) 7.调用接口在package.json中加了启动服务的命令：1\"server\": \"nodemon app.js\" 运行 npm run server，浏览器输入”localhost:3000/api/userList” ，这是刚才在api文件夹下user.js中写的获取数据的接口，调用成功后返回内容如下：这是刚才通过数据库直接插入表中的数据，接下来调用一下插入信息的接口，浏览器输入”localhost:3000/api/insertUser” ，调用成功后返回内容如下：然后看下数据库：数据插入成功了，大功告成。 over","tags":[{"name":"express","slug":"express","permalink":"http://zengdh.com/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"http://zengdh.com/tags/mongodb/"},{"name":"node","slug":"node","permalink":"http://zengdh.com/tags/node/"},{"name":"mongoose","slug":"mongoose","permalink":"http://zengdh.com/tags/mongoose/"},{"name":"body-parser","slug":"body-parser","permalink":"http://zengdh.com/tags/body-parser/"},{"name":"robomongo","slug":"robomongo","permalink":"http://zengdh.com/tags/robomongo/"}]},{"title":"初探mongodb（一）","date":"2017-06-02T06:56:26.637Z","path":"2017/06/02/note8/","text":"配置： 1.nodejs（官网地址：https://nodejs.org/en/下载安装）2.express，基于nodejs的开发框架-传送门3.mongodb4.mongoose 1.mongodb 安装配置进入mongodb官网下载安装，附上传送门，安装完成后的目录文件： logs这个目录是后面手动新建的文件夹，用来存放日志文件的。 2.修改环境变量mongodb安装完成后，将mongdb的文件目录路径添加至系统变量path下 3.创建数据库目录数据库目录不会自动创建，需要手动创建，这边我手动创建在F:\\data\\db 4.指定数据库存放目录及日志打开cmd，输入：1mongod --dbpath \"F:\\data\\db\" --logpath \"F:\\mongodb\\logs\\mongod.log\" 5.安装mongodb为windows服务通过命令启动mongo服务太麻烦，为mongodb注册系统服务，以管理员身份打开cmd，输入1mongod --install --dbpath \"F:\\data\\db\" --logpath \"F:\\mongodb\\logs\\mongod.log\" 更多设置1mongod --bind_ip yourIPadress --logpath \"F:\\mongodb\\logs\\mongod.log\" --logappend --dbpath \"D:\\data\\db\" --port yourPortNumber --serviceName \"YourServiceName\" --serviceDisplayName \"YourServiceName\" --install 参数 描述–bind_ip 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP–logpath 指定MongoDB日志文件，注意是指定文件不是目录–logappend 使用追加的方式写日志–dbpath 指定数据库路径–port 指定服务端口号，默认端口27017–serviceName 指定服务名称–serviceDisplayName 指定服务名称，有多个mongodb服务时执行。–install 指定作为一个Windows服务安装。 6.mongo服务指令添加完window服务后，以管理员身份打开cmd，启动服务输入命令：1net start MongoDB 关闭服务命令：1net stop MongoDB 7.报错如果报错“MongoDB 服务正在启动 .MongoDB 服务无法启动。发生服务特定错误: 100.”，则前去db目录下的mongod.lock和storage.bson文件删掉，以管理员身份运行命令行然后重新启动服务即可。 over","tags":[{"name":"express","slug":"express","permalink":"http://zengdh.com/tags/express/"},{"name":"mongodb","slug":"mongodb","permalink":"http://zengdh.com/tags/mongodb/"},{"name":"node","slug":"node","permalink":"http://zengdh.com/tags/node/"},{"name":"mongoose","slug":"mongoose","permalink":"http://zengdh.com/tags/mongoose/"},{"name":"body-parser","slug":"body-parser","permalink":"http://zengdh.com/tags/body-parser/"},{"name":"robomongo","slug":"robomongo","permalink":"http://zengdh.com/tags/robomongo/"}]},{"title":"前后端分离实践-gulp+express","date":"2017-05-25T02:50:44.877Z","path":"2017/05/25/note7/","text":"技术栈：gulp+express+browser-sync+seajs+sass+ejs1.前端打包工具：gulp2.express 做中间件和路由配置3.browser-sync 浏览器自动刷新4.seajs 模块化管理js5.sass css预编译6.ejs 模板引擎 1.安装express1$ npm install -g express-generator 2.新建工程12$ express -e demo$ cd demo &amp;&amp; npm install 3.修改routes引入方式app.js1234var express = require('express');var routes = require('./routes/index');var app = express();routes(app); /routes/index.js12345module.exports = function(app) &#123; app.get('/', function (req, res) &#123; res.render('index', &#123; title: 'Express' &#125;); &#125;);&#125;; 4.nodemon+browser-sync浏览器自动刷新引入依赖12var browserSync = require('browser-sync');var nodemon = require('gulp-nodemon'); 1234567891011121314151617181920212223242526// 浏览器同步，用7000端口去代理Express的3000端口gulp.task('browser-sync', ['nodemon'], function() &#123; browserSync.init(null, &#123; notify: false,//关闭页面通知 proxy: \"http://localhost:3000\", files: [\"dist/views/*.*\",\"dist/public/scss/*.*\",\"dist/public/javascripts/*.*\",\"dist/public/images/*.*\"], browser: \"chrome\", port: 7000, &#125;);&#125;);// 开启Express服务gulp.task('nodemon', function (cb) &#123; var started = false; return nodemon(&#123; script: 'bin/www' &#125;).on('start', function () &#123; //为了避免nodemon开始多次 if (!started) &#123; cb(); started = true; &#125; &#125;);&#125;); 5.http-proxy-middleware跨域1app.use('/api', proxy(&#123;target: 'http://localhost:8080', changeOrigin: true&#125;)); 6.gulp配置和之前的一样 7.ejs基本语法无缓冲的条件语句元素1&lt;% code %&gt; 转义HTML，该code并且会打印出来1&lt;%= code %&gt; 非转义的buffering，该code并且会打印出来1&lt;%- code %&gt; 内嵌别的文件1&lt;% include file %&gt; 指定布局文件1&lt;% layout(file) -%&gt; 包含js脚本文件1&lt;% script(file) -%&gt; 包含css文件1&lt;% stylesheet(file) -%&gt; 指定块内容1&lt;% block(code, code) -%&gt; 8.已上传githubhttps://github.com/zdh-chase/gulp-cli over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"seajs","slug":"seajs","permalink":"http://zengdh.com/tags/seajs/"},{"name":"sass","slug":"sass","permalink":"http://zengdh.com/tags/sass/"},{"name":"前后端分离","slug":"前后端分离","permalink":"http://zengdh.com/tags/前后端分离/"},{"name":"express","slug":"express","permalink":"http://zengdh.com/tags/express/"},{"name":"browser-sync","slug":"browser-sync","permalink":"http://zengdh.com/tags/browser-sync/"},{"name":"ejs","slug":"ejs","permalink":"http://zengdh.com/tags/ejs/"}]},{"title":"Gulp 配置（四）---模板篇","date":"2017-05-25T02:50:44.876Z","path":"2017/05/25/note4/","text":"提取公共html页面为实际开发提供了便捷，这里引入gulp-file-include做公共模块复用。 gulp-file-include需要引入的依赖1var fileinclude = require('gulp-file-include'); 新建一个task:123456789gulp.task('fileinclude', function() &#123; // 适配src中所有文件夹下的所有html，排除src下的include文件夹中html gulp.src(['./src/view/*.html','!./src/view/common/*.html']) .pipe(fileinclude(&#123; prefix: '@@', basepath: '@file' &#125;)) .pipe(gulp.dest('./build/view/'));&#125;); gulp task已经写好了，这里新建两个公共html页面，header.html和footer.html 12345header.html&lt;div&gt;这是头部&lt;/div&gt;footer.html&lt;div&gt;这是页脚&lt;/div&gt; 引入公共组件123@@include('common/header.html') &lt;div&gt;主内容&lt;/div&gt;@@include('common/footer.html') 编译后生产环境下的html123&lt;div&gt;这是头部&lt;/div&gt;&lt;div&gt;主内容&lt;/div&gt;&lt;div&gt;这是页脚&lt;/div&gt; 至此完成了html模板复用，结合上一章的自动刷新，更新下watch，将fileinclude放入watch中监听html，并刷新12345gulp.task('watch', function() &#123; gulp.watch(paths.html,['fileinclude','html']); gulp.watch(paths.scripts,['mergeScripts','html']); gulp.watch(paths.scss,['mergeScss','html']);&#125;) over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"gulp-file-include","slug":"gulp-file-include","permalink":"http://zengdh.com/tags/gulp-file-include/"}]},{"title":"git日常提交步骤-基本命令行","date":"2017-05-25T02:50:44.876Z","path":"2017/05/25/note6/","text":"1.下载代码1git clone http//xxxx.git –b dev xxxx_dev_local 注解：1) -b dev 指定想要下载的分支，去掉省略的话下载的是默认分支是master（注：默认分支可以修改）2) xxxx_dev_local是我想要在本地创建的git库文件夹名字，去掉省略的话下载好的git库名字是xxxx git库的名字，建议使用这种重命名方式 2.更新代码注：每次修改前养成同步更新代码的好习惯1git pull –rebase 如果提示冲突，说明本地git库中未入库的提交中有修改和代码库中冲突了，修改冲突文件并删除冲突标识&lt;&lt;&lt;&lt;&lt; ==== &gt;&gt;&gt;&gt;后:12git add 冲突文件名 //加入git index中git rebase –continue //继续更新到最新的base上 3.修改、增加或删除代码文件到git index缓存中修改或新增加代码文件：1git add file_name 删除代码文件：1git rm file_name 4.提交本地git库index缓存中的修改1git commit –m “just a test for commit ” 如果本地修改不对或commit的LOG需要修改可以使用：1git commit –-amend //修复上一次提交，不要修改Merge提交 ##5.更新代码注：每次push前养成同步更新代码的好习惯1git pull –rebase 如果提示冲突，说明本地git库中未入库的提交中有修改和代码库中冲突了，修改冲突文件并删除冲突标识&lt;&lt;&lt;&lt;&lt; ==== &gt;&gt;&gt;&gt;后:12git add 冲突文件名 //加入git index中git rebase –continue //继续更新到最新的base上 ##6.推送提交到服务器上的git库中1git push 注：默认会推送到我们下载git库时的-b 后面加的那个分支，没有加默认是master，这个命令完整版实际上是:1git push origin 当前分支名:我们下载的分支名 ##7.解消代码冲突12git merge xxxx_branch 或者 git pull 时 orgit rebase xxxx_branch 或者 git pull --rebase 时 解消方法也是修改冲突文件并删除冲突标识&lt;&lt;&lt;&lt;&lt; ==== &gt;&gt;&gt;：1git rebase –continue //继续更新到最新的base上 over","tags":[{"name":"git","slug":"git","permalink":"http://zengdh.com/tags/git/"}]},{"title":"Gulp 配置（五）---图片篇","date":"2017-05-25T02:50:44.876Z","path":"2017/05/25/note5/","text":"图片整合成雪碧图，几kb的图片转化成base64写入css中，减少http请求。 gulp-base64需要引入的依赖1var base64 = require('gulp-base64'); 新建一个task:1234567891011gulp.task('base64', function() &#123; return gulp.src('./build/scss/*') .pipe(base64(&#123; baseDir: './build/scss/', extensions: ['svg', 'png', /\\.jpg#datauri$/i], exclude: [/\\.server\\.(com|net)\\/dynamic\\//, '--live.jpg'], maxImageSize: 8*1024, // bytes debug: true &#125;)) .pipe(gulp.dest('./build/scss'));&#125;); gulp-css-spriter需要引入的依赖1var spriter = require('gulp-css-spriter'); 123456789101112131415161718gulp.task('mergeScss', ['cleanScss'],function ()&#123; var timestamp = +new Date(); return gulp.src(['./static/scss/*.scss']) .pipe(sass().on('error', sass.logError)) .pipe(spriter(&#123; // 生成的spriter的位置 'spriteSheet': './build/img/sprite-'+timestamp+'.png', // 生成样式文件图片引用地址的路径 // 如下将生产：backgound:url(../images/sprite20324232.png) 'pathToSpriteSheetFromCSS': '../img/sprite-'+timestamp+'.png' &#125;)) .pipe(minifycss()) .pipe(rev()) //- 文件名加MD5后缀 .pipe(gulp.dest('./build/scss/')) .pipe(rev.manifest()) //- 生成一个rev-manifest.json .pipe(gulp.dest('./rev')) //- 将 rev-manifest.json 保存到 rev 目录内 .pipe(notify(&#123; message: 'mergeScss task ok' &#125;));&#125;); css:12.x&#123;width: 50px;height: 50px;background: url(../img/x.png?__spriter) 0 0 no-repeat;&#125;.y&#123;width: 50px;height: 50px;background: url(../img/y.png) 0 0 no-repeat;&#125; 配置gulp-css-spriter默认会对样式文件里，所有的background/background-image的图片合并， 但实际项目中，我们不是所有的图片都需要合并。 123background-image:url(../img/x.png?__spriter);//有?__spriter后缀的合并background-image:url(../img/y.png);//不合并 修改gulp-css-spriter源文件进入 node_modules\\gulp-css-spriter\\lib\\map-over-styles-and-transform-background-image-declarations.js第43行：1234567891011if(transformedDeclaration.property === 'background-image') &#123; return cb(transformedDeclaration, declarationIndex, declarations); &#125; // Background is a shorthand property so make sure `url()` is in there else if(transformedDeclaration.property === 'background') &#123; var hasImageValue = spriterUtil.backgroundURLRegex.test(transformedDeclaration.value); if(hasImageValue) &#123; return cb(transformedDeclaration, declarationIndex, declarations); &#125; &#125; 更新为：123456789101112131415if(transformedDeclaration.property === 'background-image' &amp;&amp; /\\?__spriter/i.test(transformedDeclaration.value)) &#123; transformedDeclaration.value = transformedDeclaration.value.replace('?__spriter',''); return cb(transformedDeclaration, declarationIndex, declarations); &#125; // Background is a shorthand property so make sure `url()` is in there 且判断url是否有?__spriter后缀 else if(transformedDeclaration.property === 'background' &amp;&amp; /\\?__spriter/i.test(transformedDeclaration.value)) &#123; transformedDeclaration.value = transformedDeclaration.value.replace('?__spriter',''); var hasImageValue = spriterUtil.backgroundURLRegex.test(transformedDeclaration.value); if(hasImageValue) &#123; return cb(transformedDeclaration, declarationIndex, declarations); &#125; &#125; over","tags":[{"name":"base64","slug":"base64","permalink":"http://zengdh.com/tags/base64/"},{"name":"spriter","slug":"spriter","permalink":"http://zengdh.com/tags/spriter/"}]},{"title":"Gulp 配置（三）---service篇","date":"2017-05-25T02:50:44.875Z","path":"2017/05/25/note3/","text":"实际开发中，如果每次修改html、sass、js都要手动去执行编译命令，这将是一件很痛苦的事，所以配置一个本地服务，让它实时编译刷新是很必要的。 gulp-connect需要引入的依赖1var connect = require('gulp-connect'); 新建一个task:12345678gulp.task('connect', function() &#123; connect.server(&#123; // host: '192.168.x.x', //地址，可不写，不写的话，默认localhost port: 3000, //端口号，可不写，默认8000 root: './', //当前项目主目录 livereload: true //自动刷新 &#125;);&#125;); 这样就能在本地启一个服务了，但是这样还不够，我们需要去监听项目的文件是否发生更改，如果有更改就自动去编译，这里需要用到gulp-watch gulp-watch引入依赖1var sass = require('gulp-watch'); 新建一个task 12345678var paths = &#123; scripts: ['./src/js/*.js'], scss: './src/scss/*.scss',&#125;;gulp.task('watch', function() &#123; gulp.watch(paths.scripts,['mergeScripts']); gulp.watch(paths.scss,['mergeScss']);&#125;) 用watch去监听文件，当js和css发生变化时自动编译生成，但是每次都需要按F5才能更新页面，这里再写一个task去自动刷新页面，毕竟我这么懒，F5也懒得去按。 再新建一个task123456gulp.task('html', function() &#123; return gulp.src('./build/view/*.html')//这里的路径时生产文件的路径 .pipe(connect.reload());&#125;);注：task里要加return，不加return，task和里面的gulp流是异步执行的。 将它放入watch中123gulp.watch(paths.html,['html']);gulp.watch(paths.scripts,['mergeScripts','html']);gulp.watch(paths.scss,['mergeScss','html']); 这样就可以在修改源文件的同时，让gulp去自动生成需要的生产文件，这里再合并一下task，丢在一个task里面，方便使用 1gulp.task('service', ['connect', 'watch']); http-proxy-middleware 代理跨域1234567891011121314151617181920gulp.task('proxy', function() &#123; connect.server(&#123; root: ['./'], port: 3000, livereload: true, middleware: function(connect, opt) &#123; return [ proxy('/api', &#123; target: 'http://localhost:8080', changeOrigin:true &#125;), proxy('/otherServer', &#123; target: 'http://IP:Port', changeOrigin:true &#125;) ] &#125; &#125;);&#125;); over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"gulp-watch","slug":"gulp-watch","permalink":"http://zengdh.com/tags/gulp-watch/"},{"name":"gulp-connect","slug":"gulp-connect","permalink":"http://zengdh.com/tags/gulp-connect/"}]},{"title":"Gulp 配置（二）---sass篇","date":"2017-05-25T02:50:44.874Z","path":"2017/05/25/note2/","text":"sass、less、stylus都是css预处理框架，它可以提高开发效率，编写富有表现力的、动态的、健壮的CSS。 这里选择sass gulp css task需要引入的依赖12var minifycss = require('gulp-minify-css'), //压缩css rev = require('gulp-rev'); //- 对文件名加MD5后缀 123456789gulp.task('mergeCss',['cleanCss'], function() &#123; //- 创建一个名为 mergeCss 的 task return gulp.src(['./src/css/*.css']) //- 需要处理的css文件，放到一个字符串数组里 //.pipe(concat(*)) //- 合并后的文件名 .pipe(minifycss()) //- 压缩处理成一行 .pipe(rev()) //- 文件名加MD5后缀 .pipe(gulp.dest('./build/css/')) //- 输出文件本地*/ .pipe(rev.manifest()) //- 生成一个rev-manifest.json .pipe(gulp.dest('./rev')); //- 将 rev-manifest.json 保存到 rev 目录内&#125;); 普通css文件的gulp task任务，主要是css压缩+MD5时间戳+HTML路径更换 sass在开发过程中，sass需要编译才能使用，可以用命令行编译，gui编译（推荐koala），编辑器编译，在线编译等等，这里我结合gulp引入gulp-sass来编译。sass文件后缀分两种，scss和sass，一个使用{}，一个不使用，我选择scss，可读性高一些。 引入依赖1var sass = require('gulp-sass'); task任务12345678gulp.task('mergeScss', ['cleanScss'],function ()&#123; return gulp.src(['./src/scss/*.scss']) .pipe(sass().on('error', sass.logError)) .pipe(rev()) //- 文件名加MD5后缀 .pipe(gulp.dest('./build/scss/')) .pipe(rev.manifest()) //- 生成一个rev-manifest.json .pipe(gulp.dest('./rev')); //- 将 rev-manifest.json 保存到 rev 目录内&#125;); 这里编译后的css文件名是通过原文件名和md5以连字符形式命名的（例：a-f7e3d6869b.css），每次修改css后生成的文件名都不一样，需要清除原有的旧文件，否则会堆积很多没用的css，我更喜欢在html中引入css时在路径后面加‘?v={time}’的形式，这里我选择去修改node_modules里面的js文件来满足我的需求。 打开 node_modules\\gulp-rev\\index.js第144行：1manifest[originalFile] = revisionedFile; 更新为：1manifest[originalFile] = originalFile + '?v=' + file.revHash; //file.revHash是md5字符串，可以换成new Date().getTime()来获取当前时间的毫秒戳 打开 nodemodules\\gulp-rev\\nodemodules\\rev-path\\index.js第10行：1return filename + '-' + hash + ext; 更新为：1return filename + ext; 打开 node_modules\\gulp-rev-collector\\index.js第31行：1if ( !_.isString(json[key]) || path.basename(json[key]).replace(new RegExp( opts.revSuffix ), '' ) !== path.basename(key) ) &#123; 更新为：1if ( path.basename(json[key]).split('?')[0] !== path.basename(key) ) &#123; 第46行：1return pattern.replace(/[\\-\\[\\]\\&#123;\\&#125;\\(\\)\\*\\+\\?\\.\\^\\$\\|\\/\\\\]/g, \"\\\\$&amp;\"); 更新为：1234var rp = pattern.replace(/[\\-\\[\\]\\&#123;\\&#125;\\(\\)\\*\\+\\?\\.\\^\\$\\|\\/\\\\]/g, \"\\\\$&amp;\");rp = pattern + \"(\\\\?v=(\\\\d|[a-z])&#123;8,10&#125;)*\"; //匹配md5//rp = pattern + \"(\\\\?v=(\\\\d&#123;13&#125;))*\"; 匹配后缀为毫秒戳return rp; 路径替换引入依赖1var revCollector = require('gulp-rev-collector'); gulp task 123456789101112gulp.task('scssrev',['mergeScss'],function() &#123; return gulp.src( ['./rev/*.json','./build/view/*.html']) //- 读取 rev-manifest.json 文件以及需要进行css名替换的文件 .pipe(revCollector( &#123; replaceReved: true /*dirReplacements: &#123;//指定路径替换 '/static/scss': '/build/scss' &#125;*/ &#125; )) //- 执行文件内css名的替换 .pipe(gulp.dest(\"./build/view/\")); //- 替换后的文件输出的目录 &#125;); 最后这些编译后的css文件会以*.css?v={time}的形式引入，解决浏览器缓存机制。 gulp-px3rempx单位转换成rem123456789.pipe(px2rem())px2rem(&#123; baseDpr: 2, // 基本设备像素比（默认值：2） threeVersion: false, // 是否产生“1X，2X和@ @ 3x版本（默认：false） remVersion: true, // 是否生成rem版本（默认值：true） remUnit: 75, // 转化基值（默认：75） remPrecision: 6 // rem 精确度 (默认: 6)&#125;) 默认生成的css文件名格式为*.debug.css，去掉debug可以在对应的node_modules里面的index.js修改正则表达式，去掉debug就可以了。 over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"css","slug":"css","permalink":"http://zengdh.com/tags/css/"},{"name":"sass","slug":"sass","permalink":"http://zengdh.com/tags/sass/"},{"name":"px3rem","slug":"px3rem","permalink":"http://zengdh.com/tags/px3rem/"}]},{"title":"Gulp 配置（一）---seaJs篇","date":"2017-05-25T02:50:44.874Z","path":"2017/05/25/note/","text":"Gulp.js 是基于 Node.js 构建的，可以建项目并减少频繁的 IO 操作的化构建工具这里我采用 seajs来管理我的javascript代码，提高JavaScript代码的可读性和清晰度，解决目前JavaScript编程中普遍存在的依赖关系混乱和代码纠缠等问题，方便代码的编写和维护。 gulp安装就不赘述 引入seajs1&lt;script type=\"text/javascript\" src=\"../../src/js/sea.js\"&gt;&lt;/script&gt; 配置seajs1234567891011121314seajs.config(&#123; paths: &#123; 'src': '../../src/' //路径配置 &#125;, alias: &#123;//别名配置 jquery:'jquery.js', index:'src/js/index.js' &#125;, map: [//映射配置 [ /^(.*\\.(?:css|js))(.*)$/i, '$1?201703281819' ] ], preload: ['jquery'] // 预加载项 &#125;);seajs.use([\"jquery\",\"index\"]); //模块加载 更多配置项&gt;&gt; 新建两个js文件a.js和b.js12345678910111213141516171819202122232425a.js:define(function(require, exports, module) &#123; var AJS=&#123; init:function()&#123; &#125;, aDom:function()&#123; console.log('来自a.js的内容'); &#125; &#125;; module.exports=AJS;&#125;)b.js:define(function(require, exports, module) &#123; var BJS=&#123; init:function()&#123; &#125;, aDom:function()&#123; console.log('来自b.js的内容'); &#125; &#125;; module.exports=BJS;&#125;) index.js引入a.js和b.js的方法123456789101112define(function(require, exports, module) &#123; var AJS=require('a'); var BJS=require('b'); var INDEX=&#123; init:function()&#123; console.log('来自index.js的内容'); AJS.aDom(); BJS.bDom(); &#125; &#125;; module.exports=INDEX.init();&#125;) 打开引入index.js的html文件1seajs.use([\"index\"]); //引入index.js 这里可以看到index.js中成功引入了a.js和b.js的方法，再看一下Network这边加载了三个js文件，这并不符合我的需求，我希望我引入某个js文件的方法时，只需要加载那个方法，而不是整个js文件都加载进来，所以我需要合并js，添加一个gulp task任务123456789gulp.task('mergeScripts',function () &#123; return gulp.src(['./src/js/a.js','./src/js/b.js','./src/js/index.js']) .pipe(uglify(&#123;//压缩js mangle: true,//类型：Boolean 默认：true 是否修改变量名 mangle: &#123; except: ['require', 'exports', 'module', '$'] &#125;//排除混淆关键字 &#125;)) .pipe(concat('index.js')) //生成js .pipe(gulp.dest('./build/js/')); //生成合并后的js的路径 &#125;); 1gulp mergeScripts 合并是合并了，但是还是加载了三个js这里需要引入gulp-seajs-transport来具象化js模块12var transport = require('gulp-seajs-transport');.pipe(transport()); 完成，既加载了我所需要的方法，又减少了http请求over","tags":[{"name":"gulp","slug":"gulp","permalink":"http://zengdh.com/tags/gulp/"},{"name":"seajs","slug":"seajs","permalink":"http://zengdh.com/tags/seajs/"},{"name":"gulp-seajs-transport","slug":"gulp-seajs-transport","permalink":"http://zengdh.com/tags/gulp-seajs-transport/"}]}]